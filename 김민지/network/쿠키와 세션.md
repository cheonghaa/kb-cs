# 쿠키(Cookie)와 세션(Session)


## HTTP 프로토콜 특징

- `클라이언트 서버 구조`
    - 클라이언트가 서버에 요청(request)을 보내면, 서버는 그에 대한 응답(response)를 보냄
- `비연결 지향(Connectionless)`
    - 클라이언트의 요청에 응답한 후에는 연결을 끊음(연결 유지 X)
    - 최소한의 자원으로 서버 유지
- `무상태(Stateless)`
    - 연결을 끊는 순간 클라이언트와 서버의 통신이 끝나고, 서버는 클라이언트의 상태 정보를 보존하지 않음
    - 클라이언트가 요청할 때 필요한 데이터를 추가적으로 담아서 전송해야 함
        - 서버 독립성 : 어떤 서버에 요청하든 같은 결과를 받으면 되기 때문에, 항상 같은 서버를 유지하지 않아도 됨. 
        - 이게 가능해서 서버 간에 로드 밸런싱이 쉬워지고, 서버를 확장하거나 교체할 때 유연성이 높아짐.


**쿠키와 세션의 필요성**

- HTTP 프로토콜의 특징으로 모든 요청 간에는 의존관계가 없음
    - 현재 접속한 사용자가 이전에 접속했던 사용자와 같은 사용자인지 아닌지 알 수 있는 방법 존재 X
  - 통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 `인증`을 해야 함
      - 로그인을 진행한 후, 다른 서비스를 사용하기 위해 매번 로그인(인증)을 하는 상황 발생
-  클라이언트의 상태 정보를 유지할 필요가 있을 경우, `쿠키`와 `세션`을 활용해서 Stateful한 동작 구현 가능
    - 무상태를 지향하기 위해 매 요청마다 필요한 정보를 담아 서버와 통신하는 경우, 비용과 부하가 커질 수 있음
    - 필요한 정보만을 전송하고, 나머지 상태 정보는 서버나 클라이언트에 저장하여 유지할 수 있기 때문에, 데이터 전송량을 줄이고, 서버의 처리 비용도 줄일 수 있음.

<br/>

## 쿠키(Cookie)

- 개념
    - `클라이언트 로컬`에 저장되는 키와 값이 들어있는 파일
    - 사용자 인증이 유효한 시간 명시 가능(유효시간이 정해지면 브라우저가 종료되어도 인증 유지)
    - 클라이언트의 상태 정보를 브라우저(로컬)에 저장하여 참조
- 구성 요소
    - 쿠키의 이름(name)
    - 쿠키의 값(value)
    - 쿠키의 유효시간(Expires)
    - 쿠키를 전송할 도메인 이름(Domain)
    - 쿠키를 전송할 요청 경로(Path)
- 동작 방식
    1. 웹브라우저가 서버에 요청
    2. 상태를 유지하고 싶은 값을 쿠키(cookie)로 생성
    3. 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 쿠키를 포함해서 전송
    4. 전달받은 쿠키는 웹 브라우저가 관리, 다음 요청 때 쿠키를 HTTP 헤더에 자동으로 넣어서 전송
    5. 서버에서 쿠키 정보를 읽어 이전 상태 정보를 확인 후 응답
- 사용 예
    - 아이디, 비밀번호 저장
    - 쇼핑몰 장바구니


<br/>

## 세션(Session)

- 개념
    - 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지함
        - 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태 
    - 사용자 정보 파일을 쿠키는 브라우저에 저장하고, 세션은 서버측에서 관리
      - 사용자에 대한 정보를 서버에 두기 때문에, 사용자가 많아질수록 서버 메모리 많이 차지
    - 보안 면에서 쿠키보다 우수
        - 쿠키는 클라이언트 측에서 쉽게 탈취 가능
            - 쿠키는 클라이언트 측에서 변경이 가능한 반면, 세션은 서버에서만 변경 가능
        - 세션ID값 탈취는 적극적인 해킹공격으로 쿠키보다 어려움
- 동작 방식
    1. 웹브라우저가 서버에 요청
    2. 서버가 해당 웹브라우저(클라이언트)에 유일한 ID(Session ID)를 부여함
    3. 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 Session ID를 포함해서 전송
    4. 웹브라우저는 부여된 Session ID를 쿠키에 저장해두고, 다음 요청 때마다 해당 쿠키를 HTTP 헤더에 넣어서 전송
    5. 서버는 Session ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답
        - 로그인을 하는 경우, 해당 Session ID의 로그인 상태를 유효한 값으로 바꿔 저장
        - 이후 요청에서 해당 Session ID를 가진 클라이언트는 로그인 상태가 유효하므로 별도의 로그인 없이 서비스 이용 가능
- 사용 예
    - 로그인

<br/>

**다중 서버 환경에서 세션 관리 방법**

서버를 다중화했을 경우, 세션 불일치 이슈 발생

- `Sticky Session` (스티키 세션)
    - 클라이언트의 요청이 항상 해당 클라이언트의 세션이 저장된 서버로만 전달됨
        - 로드밸런서에서 요청 쿠키(Session ID)를 읽고 지정된 서버(세션이 있는)로만 요청을 전달함
        - 세션 정보가 없을 경우, 로드밸런서의 기본 알고리즘대로 요청 전달 
    - 장점
      - 구현이 간단하고 기존 세션 관리 로직을 변경할 필요가 없음. 
    - 단점
      - 서버 간 부하 분산이 불균형해질 수 있음. 
      - 특정 서버에 트래픽이 집중될 수 있고, 해당 서버가 다운되면 세션이 유지되지 않음.

- `Session Clustering` (세션 클러스터링)
    - 클러스터링: 병렬 처리해서 여러 대의 서버를 하나의 서버처럼 운영
    - 세션을 서버 각각에 복사해서 모든 서버가 모든 세션을 보유하고 있음
    - 특정 서버에서 세션이 생성될 때 다른 서버로 세션을 전파하여 복제
    - 장점
      - 세션 지속성이 보장됨. 
      - 한 서버가 다운되더라도 다른 서버에서 세션을 유지할 수 있음. 
    - 단점
      - 서버 간의 네트워크 트래픽이 증가하며, 성능 저하가 발생할 수 있음. 
      - 확장성이 떨어질 수 있음.

- `Session Storage` (세션 스토리지)
    - 세션만 관리하는 별도의 DB 서버를 두고, 모든 서버가 해당 서버를 참조함
    - 장점
      - 중앙 집중식으로 세션 관리가 가능하고, 서버 추가에 영향을 받지 않음. 
      - 확장성이 뛰어나며, 서버 장애에 대해 견고함. 
    - 단점
      - 외부 스토리지의 성능과 가용성에 따라 전체 시스템 성능이 영향을 받을 수 있음. 
      - 외부 스토리지의 장애가 발생하면 전체 세션 관리에 문제가 생길 수 있음.
- `JWT (JSON Web Token) 기반 세션 관리`
    - 서버에서 세션 상태를 관리하지 않고, JWT 토큰을 사용하여 클라이언트에 모든 세션 상태를 담아 전송함. 
    - 클라이언트는 이후 요청에서 이 JWT를 서버에 전달함.
    - 장점
      - 서버의 상태 관리 부담이 줄어들고, 서버 간 세션 동기화가 필요 없음. 
      - 확장성이 뛰어남. 
    - 단점
      - JWT의 크기가 커질 수 있으며, 보안이 중요한 애플리케이션에서는 주의가 필요함. 
      - 토큰이 클라이언트에 저장되기 때문에 만료 시점을 관리하는 것이 복잡해질 수 있음.

<br/>

**세션관리 방법 중 좋은 대안은?**
- 애플리케이션의 요구 사항과 아키텍처에 따라 달라짐 
  - **작고 단순한 웹 애플리케이션**에서는 `Sticky Session`이 간단하고 적합할 수 있음. 
  - **중간 규모의 애플리케이션**에서는 `Session Storage`(예: Redis)를 사용하는 것이 좋음. 이는 세션 관리의 확장성과 안정성을 보장할 수 있음. 
  - **고성능, 고가용성 애플리케이션**에서는 `JWT 기반의 세션 관리`가 유리할 수 있음. 서버 상태에 의존하지 않기 때문에 확장성과 성능에서 큰 이점이 있음.

> 대부분의 경우 `Session Storage`를 사용하는 방법이 좋은 선택임.
>이 방법은 확장성이 뛰어나고, 서버 장애에 대한 복원력이 높아 다중 서버 환경에서 안정적으로 세션을 관리할 수 있음. 
> 
>다만, 무상태 서버 설계가 가능하다면 `JWT 기반 접근`도 매우 좋은 대안임.

<br/>



### 쿠키와 세션의 차이

||쿠키|세션|
|-----|:---------:|:------:|
|저장 위치|클라이언트의 웹 브라우저가 지정하는 메모리 or 하드디스크|서버 메모리|
|저장 형식|Text|Object|
|만료 시점|쿠키 저장 시 설정|정확한 시점 알 수 없음|
|보안|클라이언트에 저장되므로 취약|Session ID만 저장하고, 이 값에 따라 서버에서 처리하므로  비교적 보안성 좋음|
|속도|클라이언트에 저장되어 서버에 요청 시 빠름|정보가 서버에 저장되어 있어 서버 처리가 필요해 쿠키보다 느림|
|용량 제한|한 도메인 당 20개, 한 쿠키당 4KB|제한없음|


<br>
<br>

**토근 기반 인증 방식**
- 세션은 사용자의 수 만큼 서버 메모리를 차지하기 때문에, 최근에는 이를 보완하는 토근 기반의 인증방식을 많이 사용함(`stateless`)
- ex) `JWT(JSON Web Token)`


<br/>

## ➕ 토큰

- 개념
    - 메모리 공간을 많이 차지하는 세션 방식의 대안으로 사용자에게 `세션 아이디` 대신 `토큰`을 발급
    - 서버는 사용자 정보를 기반으로 토큰 생성. 이를 서버가 따로 저장하지 않고, 클라이언트에 전달하면 클라이언트가 이를 저장하고 있다가 매 요청마다 헤더에 담아서 전송.
    - 서버는 클라이언트로부터 받은 토큰을 해석(검증)하여 사용자 상태를 파악하는 방법

<br>

- 동작 방식
    1. 클라이언트가 서버에 접속 시, 서버는 클라이언트에게 인증되었다는 의미로 `토큰` 부여 (해당 토큰은 유일함)
        - 클라이언트는 전달받은 토큰을 쿠키나 스토리지에 저장함
    2. 토큰을 발급받은 클라이언트는 다시 서버에 요청을 보낼 때 헤더에 토큰을 심어보냄
    3. 서버의 토큰 일치여부 체크로 인증과정 처리
        - 클라이언트로부터 받은 토큰과 서버에서 제공한 토큰의 일치여부 체크

<br>

- 특징
    - 적은 서버의 부담
        - 토큰은 클라이언트에 저장 됨 → 세션을 관리했던 서버의 부담을 덜 수 있음
        - 해당 서버만이 만들 수 있는 토큰 발급 → 상태를 저장하지 않고도 사용자의 정보 파악 가능

<br>

- 한계
    - 한 번 발행한 토큰은 유효기간 만료시 까지 통제 불가
        - 여러 기기에서 로그인 제한 불가
        - 세션에 비해 토큰 정보 탈취 당할 가능성 높음
            - 해결 방법으로 `만료 시간` 이용
    - 토큰 자체 데이터 길이가 긺
        - 인증 요청이 많아질 수록 네트워크 부하가 심해짐

<br>
<br>