## 쿠키 (Cookie)

### 1. 정의 및 특징

- 쿠키는 클라이언트 측에서 관리하는 key-value 형태의 작은 데이터 조각
- 서버에 의해 생성 / 클라이언트 측에서 관리하는 key-value 형태의 작은 데이터 조각
- 쿠키이름, 쿠키값, 만료시간, 전송할 도메인명, 전송할 경로, 보안연결여부, HttpOnly여부로 구성
- 쿠키는 설정된 유효 기간이 만료되면 자동으로 삭제되며, 세션 쿠키의 경우 브라우저가 닫힐 때까지 유지
- 쿠키의 크기는 보통 4KB 정도로 제한

### 2. 동작방식

1. 클라이언트가 서버에 요청
2. 서버는 클라이언트에 쿠키를 설정하고, 이를 HTTP 응답의 `Set-Cookie` 헤더를 통해 전송합니다.
3. 클라이언트(브라우저)는 이 쿠키를 로컬에 저장.
이후 클라이언트가 동일한 서버에 요청을 보낼 때, 저장된 쿠키를 HTTP 요청의 헤더에 포함하여 서버로 전송
4. 서버는 이 쿠키를 통해 클라이언트의 상태를 파악하거나 식별

### 3. 장단점

**장점**

- 쿠키는 클라이언트 측에 저장되므로 서버 자원을 거의 소모하지 않음
- 상태정보 유지가 간단하고 사용자 개인화 옵션(언어, 테마, 레이아웃)을 저장/관리 쉬움

**단점**

- 쿠키는 클라이언트 측에 저장되므로, XSS 등의 공격에 취약
- 데이터 크기 제한(4kb)
- 쿠키는 매 요청마다 서버로 전송되므로, 쿠키가 큰 경우에는 네트워크 트래픽이 증가하여 서버의 부하가 늘어날 수 있음

---

## 세션

### 1. 정의 및 특징

- 서버에 인증하기 위한 클라이언트의 정보를 서버 단에서 저장 및 관리하는 방식
- 클라이언트와 서버 간의 연결 동안 사용자 식별 및 상태 유지를 위해 사용

### 2. 동작방식

1. 클라이언트가 서버에게 페이지 정보를 요청
2. 서버는 클라이언트에 대한 쿠키 생성 후, HTTP 응답의 `Set-Cookie`헤더에 세션 ID 값이 담긴 쿠키를 포함하여 응답
3. 클라이언트의 요청과 서버의 응답이 끝나면 HTTP의 비연결성으로 인해 연결 끊김
4. 새로운 요청을 할 경우, 이전에 받은 쿠키값을 보관(SSID, JSESSIONID 등)했다가 HTTP 요청 헤더에 세션 ID 값이 담긴 쿠키를 포함하여 요청 (HTTP request 헤더의 'cookie')
5. 서버는 쿠키 내 세션 ID 값을 보고 이전에 요청을 보낸 클라이언트를 인식하여 상태를 기억하여 HTTP의 Stateless한 성질을 보완

> 쿠키와 세션의 동작방식은 비슷하다. 차이점이 있다면, 쿠키 값 내 서버가 준 세션 ID에 대한 정보를 서버와 클라이언트가 주고 받으며 서버에 클라이언트를 인증하는 것. (세션 ID는 서버가 발급하고 관리)
> 

### 3. 장단점

**장점**

- 쿠키에 비해서는 안전하다. (세션 ID가 클라이언트에 저장되지만, 클라이언트의 정보 자체는 서버에 저장되어 관리되기 때문)
- 큰 데이터를 관리하기 용이하다

**단점**

- 세션ID를 주고 받은 다음 인증을 거쳐 서버의 데이터를 참조해야 하므로 속도가 조금 느리다.
- 서버 자원을 소모함
- 세션 관리에 추가적인 로직이 필요
- 해킹의 위험성은 여전히 존재 ex) 세션 하이재킹 (Session Hi-jacking)

---

**Q1. 쿠키와 세션의 차이**

쿠키는 클라이언트 측에 저장되며, 클라이언트가 서버에 요청할 때마다 자동으로 전송됩니다. 반면, 세션은 서버 측에 저장되어 클라이언트를 식별하는 데 사용됩니다. 쿠키는 보안상 취약하지만, 세션은 서버에서 관리되어 상대적으로 안전합니다. 또한, 쿠키는 브라우저를 닫아도 유지될 수 있지만, 세션은 기본적으로 브라우저 종료 시 만료됩니다.

**Q2. 세션 방식의 로그인 과정**

세션 방식의 로그인은 사용자가 로그인 정보를 서버로 전송하면, 서버가 이를 확인한 후 세션을 생성하고 고유한 세션 ID를 클라이언트에 전달하는 방식입니다. 클라이언트는 이 세션 ID를 쿠키에 저장하고, 이후 요청 시마다 이 세션 ID를 서버로 보내 사용자 상태를 유지합니다. 서버는 이 세션 ID를 통해 사용자 정보를 참조하여 요청을 처리합니다.

**Q3. HTTP의 특성인 Stateless?**

HTTP는 Stateless 프로토콜로, 각 요청이 독립적으로 처리됩니다. 서버는 클라이언트의 이전 요청 상태를 기억하지 않으며, 요청 간의 연관성을 유지하지 않습니다. 이로 인해 HTTP는 단순하고 확장성이 높지만, 상태를 유지하기 위해 추가적인 방법이 필요합니다.

**Q4. Stateless와 세션의 관계**

Stateless한 HTTP에서 상태를 유지하기 위해 세션이 사용됩니다. 비록 HTTP 자체는 상태를 기억하지 않지만, 서버는 세션 ID를 통해 클라이언트의 상태를 추적할 수 있습니다. 따라서, 세션은 Stateless 환경에서도 상태를 유지할 수 있게 해주는 적절한 인증 방법입니다.

**Q5. 규모 확장 시 세션 관리 방법**

서버가 여러 대로 확장될 경우, 세션 관리는 중앙 집중식 세션 저장소(예: Redis)를 사용하거나, 로드 밸런서를 통해 특정 사용자의 요청을 항상 같은 서버로 보내는 Sticky Session 방식을 사용해 해결할 수 있습니다. 이를 통해 서버 간 일관된 세션 관리를 유지할 수 있습니다.